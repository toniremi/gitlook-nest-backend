{
  "/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/serverless.yaml": {
    "versionFramework": "4.17.1",
    "servicePath": "/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/serverless.yaml",
    "serviceConfigFileName": "serverless.yaml",
    "service": {
      "service": "gitlook-nest-backend",
      "frameworkVersion": "4",
      "provider": {
        "name": "aws",
        "runtime": "nodejs20.x",
        "region": "ap-northeast-3",
        "memorySize": 1024,
        "timeout": 30,
        "stage": "dev",
        "environment": {
          "GITHUB_CLIENT_ID": "Ov23liEySRAD8dPXpFy9",
          "GITHUB_CLIENT_SECRET": "<REDACTED>"
        },
        "iam": {
          "role": {
            "statements": [
              {
                "Effect": "Allow",
                "Action": [
                  "ssm:GetParameter"
                ],
                "Resource": [
                  "arn:aws:ssm:ap-northeast-3:*:parameter/gitlook-nest-backend/dev/github-client-id",
                  "arn:aws:ssm:ap-northeast-3:*:parameter/gitlook-nest-backend/dev/github-client-secret"
                ]
              }
            ]
          }
        },
        "versionFunctions": true
      },
      "build": {
        "esbuild": {
          "bundle": true,
          "minify": false,
          "sourcemap": true,
          "target": "node20",
          "external": [
            "@aws-sdk/*"
          ]
        }
      },
      "functions": {
        "main": {
          "handler": "lambda.handler",
          "events": [
            {
              "httpApi": {
                "routeKey": "ANY /",
                "isHttpApi": true,
                "payload": "2.0"
              }
            },
            {
              "httpApi": {
                "routeKey": " /{proxy+}",
                "isHttpApi": true,
                "payload": "2.0"
              }
            }
          ],
          "name": "gitlook-nest-backend-dev-main"
        }
      },
      "package": {
        "patterns": [
          "!node_modules/**",
          "!src/**",
          "!test/**",
          "package.json",
          "package-lock.json",
          "!serverless.yml"
        ],
        "artifactsS3KeyDirname": "serverless/gitlook-nest-backend/dev/code-artifacts"
      },
      "plugins": [
        "serverless-offline"
      ]
    },
    "provider": {
      "name": "aws",
      "runtime": "nodejs20.x",
      "region": "ap-northeast-3",
      "memorySize": 1024,
      "timeout": 30,
      "stage": "dev",
      "environment": {
        "GITHUB_CLIENT_ID": "Ov23liEySRAD8dPXpFy9",
        "GITHUB_CLIENT_SECRET": "<REDACTED>"
      },
      "iam": {
        "role": {
          "statements": [
            {
              "Effect": "Allow",
              "Action": [
                "ssm:GetParameter"
              ],
              "Resource": [
                "arn:aws:ssm:ap-northeast-3:*:parameter/gitlook-nest-backend/dev/github-client-id",
                "arn:aws:ssm:ap-northeast-3:*:parameter/gitlook-nest-backend/dev/github-client-secret"
              ]
            }
          ]
        }
      },
      "versionFunctions": true
    },
    "dashboard": {
      "isEnabledForService": false,
      "requiredAuthentication": false,
      "orgFeaturesInUse": null,
      "orgObservabilityIntegrations": null,
      "serviceAppId": null,
      "serviceProvider": null,
      "instanceParameters": null
    },
    "error": {
      "message": "Invalid route options ( /{proxy*}) {\n  \"handler\": \"[async (request, h) => {\\n      const requestPath =\\n        endpoint.isHttpApi || this.#options.noPrependStageInUrl\\n          ? request.path\\n          : request.path.substr(`/${stage}`.length)\\n\\n      // payload processing\\n      const encoding = detectEncoding(request)\\n\\n      request.raw.req.payload = request.payload\\n      request.payload = request.payload && request.payload.toString(encoding)\\n      request.rawPayload = request.payload\\n\\n      // incoming request message\\n      log.notice()\\n\\n      log.notice()\\n      log.notice(`${method} ${request.path} (Î»: ${functionKey})`)\\n\\n      // check for APIKey\\n      if (\\n        (protectedRoute === `${hapiMethod}#${hapiPath}` ||\\n          protectedRoute === `ANY#${hapiPath}`) &&\\n        !this.#options.noAuth\\n      ) {\\n        const errorResponse = () =>\\n          h\\n            .response({\\n              message: \\\"Forbidden\\\",\\n            })\\n            .code(403)\\n            .header(\\\"x-amzn-ErrorType\\\", \\\"ForbiddenException\\\")\\n            .type(\\\"application/json\\\")\\n\\n        const apiKey = request.headers[\\\"x-api-key\\\"]\\n\\n        if (apiKey) {\\n          if (!this.#apiKeysValues.has(apiKey)) {\\n            log.debug(\\n              `Method '${method}' of function '${functionKey}' token '${apiKey}' not valid.`,\\n            )\\n\\n            return errorResponse()\\n          }\\n        } else if (\\n          request.auth &&\\n          request.auth.credentials &&\\n          request.auth.credentials.usageIdentifierKey\\n        ) {\\n          const { usageIdentifierKey } = request.auth.credentials\\n\\n          if (!this.#apiKeysValues.has(usageIdentifierKey)) {\\n            log.debug(\\n              `Method '${method}' of function '${functionKey}' token '${usageIdentifierKey}' not valid.`,\\n            )\\n\\n            return errorResponse()\\n          }\\n        } else {\\n          log.debug(`Missing 'x-api-key' on private function '${functionKey}'.`)\\n\\n          return errorResponse()\\n        }\\n      }\\n\\n      const response = h.response()\\n      const contentType = request.mime || \\\"application/json\\\" // default content type\\n\\n      const { integration, requestTemplates } = endpoint\\n\\n      // default request template to '' if we don't have a definition pushed in from serverless or endpoint\\n      const requestTemplate =\\n        requestTemplates !== undefined && integration === \\\"AWS\\\"\\n          ? requestTemplates[contentType]\\n          : \\\"\\\"\\n\\n      const schemas =\\n        endpoint?.request?.schemas === undefined\\n          ? \\\"\\\"\\n          : endpoint.request.schemas[contentType]\\n\\n      // https://hapijs.com/api#route-configuration doesn't seem to support selectively parsing\\n      // so we have to do it ourselves\\n      const contentTypesThatRequirePayloadParsing = [\\n        \\\"application/json\\\",\\n        \\\"application/vnd.api+json\\\",\\n      ]\\n\\n      if (\\n        contentTypesThatRequirePayloadParsing.includes(contentType) &&\\n        request.payload &&\\n        request.payload.length > 1\\n      ) {\\n        try {\\n          if (!request.payload || request.payload.length === 0) {\\n            request.payload = \\\"{}\\\"\\n          }\\n\\n          request.payload = parse(request.payload)\\n        } catch (err) {\\n          log.debug(\\\"error in converting request.payload to JSON:\\\", err)\\n        }\\n      }\\n\\n      log.debug(\\\"contentType:\\\", contentType)\\n      log.debug(\\\"requestTemplate:\\\", requestTemplate)\\n      log.debug(\\\"payload:\\\", request.payload)\\n\\n      /* REQUEST PAYLOAD SCHEMA VALIDATION */\\n      if (schemas) {\\n        log.debug(\\\"schemas:\\\", schemas)\\n\\n        try {\\n          payloadSchemaValidator(schemas, request.payload)\\n        } catch (err) {\\n          return this.#reply400(response, err.message, err)\\n        }\\n      }\\n\\n      /* REQUEST TEMPLATE PROCESSING (event population) */\\n\\n      let event = {}\\n\\n      if (integration === \\\"AWS\\\") {\\n        if (requestTemplate) {\\n          try {\\n            log.debug(\\\"_____ REQUEST TEMPLATE PROCESSING _____\\\")\\n\\n            event = new LambdaIntegrationEvent(\\n              request,\\n              stage,\\n              requestTemplate,\\n              requestPath,\\n            ).create()\\n          } catch (err) {\\n            return this.#reply502(\\n              response,\\n              `Error while parsing template \\\"${contentType}\\\" for ${functionKey}`,\\n              err,\\n            )\\n          }\\n        } else if (typeof request.payload === \\\"object\\\") {\\n          event = request.payload || {}\\n        }\\n      } else if (integration === \\\"AWS_PROXY\\\") {\\n        const lambdaProxyIntegrationEvent =\\n          endpoint.isHttpApi && endpoint.payload === \\\"2.0\\\"\\n            ? new LambdaProxyIntegrationEventV2(\\n                request,\\n                stage,\\n                endpoint.routeKey,\\n                additionalRequestContext,\\n              )\\n            : new LambdaProxyIntegrationEvent(\\n                request,\\n                stage,\\n                requestPath,\\n                endpoint.isHttpApi ? endpoint.routeKey : null,\\n                additionalRequestContext,\\n              )\\n\\n        event = lambdaProxyIntegrationEvent.create()\\n\\n        const customizations = this.#serverless.service.custom\\n        const hasCustomAuthProvider =\\n          customizations?.offline?.customAuthenticationProvider\\n\\n        if (!endpoint.authorizer && !hasCustomAuthProvider) {\\n          log.debug(\\\"no authorizer configured, deleting authorizer payload\\\")\\n          delete event.requestContext.authorizer\\n        }\\n      }\\n\\n      log.debug(\\\"event:\\\", event)\\n\\n      const lambdaFunction = this.#lambda.get(functionKey)\\n\\n      lambdaFunction.setEvent(event)\\n\\n      let result\\n      let err\\n\\n      try {\\n        result = await lambdaFunction.runHandler()\\n      } catch (_err) {\\n        err = _err\\n      }\\n\\n      // const processResponse = (err, data) => {\\n      // Everything in this block happens once the lambda function has resolved\\n\\n      log.debug(\\\"_____ HANDLER RESOLVED _____\\\")\\n\\n      let responseName = \\\"default\\\"\\n      const { contentHandling, responseContentType } = endpoint\\n\\n      /* RESPONSE SELECTION (among endpoint's possible responses) */\\n\\n      // Failure handling\\n      let errorStatusCode = \\\"502\\\"\\n\\n      if (err) {\\n        const errorMessage = (err.message || err).toString()\\n\\n        const found = errorMessage.match(/\\\\[(\\\\d{3})]/)\\n\\n        if (found && found.length > 1) {\\n          ;[, errorStatusCode] = found\\n        } else {\\n          errorStatusCode = \\\"502\\\"\\n        }\\n\\n        // Mocks Lambda errors\\n        result = {\\n          errorMessage,\\n          errorType: err.constructor.name,\\n          stackTrace: this.#getArrayStackTrace(err.stack),\\n        }\\n\\n        log.error(errorMessage)\\n\\n        for (const [key, value] of entries(endpoint.responses)) {\\n          if (\\n            key !== \\\"default\\\" &&\\n            `^${value.selectionPattern || key}$`.test(errorMessage)\\n          ) {\\n            responseName = key\\n            break\\n          }\\n        }\\n      }\\n\\n      log.debug(`Using response '${responseName}'`)\\n\\n      const chosenResponse = endpoint.responses?.[responseName] ?? {}\\n      /* RESPONSE PARAMETERS PROCCESSING */\\n\\n      const { responseParameters } = chosenResponse\\n\\n      if (responseParameters) {\\n        log.debug(\\\"_____ RESPONSE PARAMETERS PROCCESSING _____\\\")\\n        log.debug(\\n          `Found ${\\n            keys(responseParameters).length\\n          } responseParameters for '${responseName}' response`,\\n        )\\n\\n        // responseParameters use the following shape: \\\"key\\\": \\\"value\\\"\\n        entries(responseParameters).forEach(([key, value]) => {\\n          const keyArray = key.split(\\\".\\\") // eg: \\\"method.response.header.location\\\"\\n          const valueArray = value.split(\\\".\\\") // eg: \\\"integration.response.body.redirect.url\\\"\\n\\n          log.debug(`Processing responseParameter \\\"${key}\\\": \\\"${value}\\\"`)\\n\\n          // For now the plugin only supports modifying headers\\n          if (key.startsWith(\\\"method.response.header\\\") && keyArray[3]) {\\n            const headerName = keyArray.slice(3).join(\\\".\\\")\\n            let headerValue\\n\\n            log.debug(\\\"Found header in left-hand:\\\", headerName)\\n\\n            if (value.startsWith(\\\"integration.response\\\")) {\\n              if (valueArray[2] === \\\"body\\\") {\\n                log.debug(\\\"Found body in right-hand\\\")\\n\\n                headerValue = valueArray[3]\\n                  ? jsonPath(result, valueArray.slice(3).join(\\\".\\\"))\\n                  : result\\n\\n                headerValue = headerValue == null ? \\\"\\\" : String(headerValue)\\n              } else {\\n                log.notice()\\n\\n                log.warning()\\n                log.warning(\\n                  `Offline plugin only supports \\\"integration.response.body[.JSON_path]\\\" right-hand responseParameter. Found \\\"${value}\\\" (for \\\"${key}\\\"\\\") instead. Skipping.`,\\n                )\\n\\n                this.#logPluginIssue()\\n                log.notice()\\n              }\\n            } else {\\n              headerValue = /^'.*'$/.test(value) ? value.slice(1, -1) : value // See #34\\n            }\\n            // Applies the header;\\n            if (headerValue === \\\"\\\") {\\n              log.warning(\\n                `Empty value for responseParameter \\\"${key}\\\": \\\"${value}\\\", it won't be set`,\\n              )\\n            } else {\\n              log.debug(\\n                `Will assign \\\"${headerValue}\\\" to header \\\"${headerName}\\\"`,\\n              )\\n\\n              response.header(headerName, headerValue)\\n            }\\n          } else {\\n            log.notice()\\n\\n            log.warning()\\n            log.warning(\\n              `Offline plugin only supports \\\"method.response.header.PARAM_NAME\\\" left-hand responseParameter. Found \\\"${key}\\\" instead. Skipping.`,\\n            )\\n\\n            this.#logPluginIssue()\\n            log.notice()\\n          }\\n        })\\n      }\\n\\n      let statusCode = 200\\n\\n      if (integration === \\\"AWS\\\") {\\n        const endpointResponseHeaders =\\n          (endpoint.response && endpoint.response.headers) || {}\\n\\n        entries(endpointResponseHeaders)\\n          .filter(\\n            ([, value]) => typeof value === \\\"string\\\" && /^'.*?'$/.test(value),\\n          )\\n          .forEach(([key, value]) => response.header(key, value.slice(1, -1)))\\n\\n        /* LAMBDA INTEGRATION RESPONSE TEMPLATE PROCCESSING */\\n\\n        // If there is a responseTemplate, we apply it to the result\\n        const { responseTemplates } = chosenResponse\\n\\n        if (\\n          typeof responseTemplates === \\\"object\\\" &&\\n          keys(responseTemplates).length > 0\\n        ) {\\n          // BAD IMPLEMENTATION: first key in responseTemplates\\n          const responseTemplate = responseTemplates[responseContentType]\\n\\n          if (responseTemplate && responseTemplate !== \\\"\\\\n\\\") {\\n            log.debug(\\\"_____ RESPONSE TEMPLATE PROCCESSING _____\\\")\\n            log.debug(`Using responseTemplate '${responseContentType}'`)\\n\\n            try {\\n              const reponseContext = new VelocityContext(\\n                request,\\n                stage,\\n                result,\\n              ).getContext()\\n\\n              result = renderVelocityTemplateObject(\\n                {\\n                  root: responseTemplate,\\n                },\\n                reponseContext,\\n              ).root\\n            } catch (error) {\\n              log.error(\\n                `Error while parsing responseTemplate '${responseContentType}' for lambda ${functionKey}:\\\\n${error.stack}`,\\n              )\\n            }\\n          }\\n        }\\n\\n        /* LAMBDA INTEGRATION HAPIJS RESPONSE CONFIGURATION */\\n        statusCode = chosenResponse.statusCode || 200\\n\\n        if (err) {\\n          statusCode = errorStatusCode\\n        }\\n\\n        if (!chosenResponse.statusCode) {\\n          log.notice()\\n\\n          log.warning()\\n          log.warning(`No statusCode found for response \\\"${responseName}\\\".`)\\n        }\\n\\n        response.header(\\\"Content-Type\\\", responseContentType, {\\n          override: false, // Maybe a responseParameter set it already. See #34\\n        })\\n\\n        response.statusCode = statusCode\\n\\n        if (contentHandling === \\\"CONVERT_TO_BINARY\\\") {\\n          response.encoding = \\\"binary\\\"\\n          response.source = Buffer.from(result, \\\"base64\\\")\\n          response.variety = \\\"buffer\\\"\\n        } else if (typeof result === \\\"string\\\") {\\n          response.source = stringify(result)\\n        } else {\\n          response.source = result\\n        }\\n      } else if (integration === \\\"AWS_PROXY\\\") {\\n        /* LAMBDA PROXY INTEGRATION HAPIJS RESPONSE CONFIGURATION */\\n\\n        if (\\n          endpoint.isHttpApi &&\\n          endpoint.payload === \\\"2.0\\\" &&\\n          (typeof result === \\\"string\\\" || !result.statusCode)\\n        ) {\\n          const body = typeof result === \\\"string\\\" ? result : stringify(result)\\n          result = {\\n            body,\\n            headers: {\\n              \\\"Content-Type\\\": \\\"application/json\\\",\\n            },\\n            isBase64Encoded: false,\\n            statusCode: 200,\\n          }\\n        }\\n\\n        if (result && !result.errorType) {\\n          statusCode = result.statusCode || 200\\n        } else if (err) {\\n          statusCode = errorStatusCode || 502\\n        } else {\\n          statusCode = 502\\n        }\\n\\n        response.statusCode = statusCode\\n\\n        const headers = {}\\n\\n        if (result && result.headers) {\\n          entries(result.headers).forEach(([headerKey, headerValue]) => {\\n            headers[headerKey] = (headers[headerKey] || []).concat(headerValue)\\n          })\\n        }\\n        if (result && result.multiValueHeaders) {\\n          entries(result.multiValueHeaders).forEach(\\n            ([headerKey, headerValue]) => {\\n              headers[headerKey] = (headers[headerKey] || []).concat(\\n                headerValue,\\n              )\\n            },\\n          )\\n        }\\n\\n        log.debug(\\\"headers\\\", headers)\\n\\n        const parseCookies = (headerValue) => {\\n          const cookieName = headerValue.slice(0, headerValue.indexOf(\\\"=\\\"))\\n          const cookieValue = headerValue.slice(headerValue.indexOf(\\\"=\\\") + 1)\\n\\n          h.state(cookieName, cookieValue, {\\n            encoding: \\\"none\\\",\\n            strictHeader: false,\\n          })\\n        }\\n\\n        entries(headers).forEach(([headerKey, headerValue]) => {\\n          if (headerKey.toLowerCase() === \\\"set-cookie\\\") {\\n            headerValue.forEach(parseCookies)\\n          } else {\\n            headerValue.forEach((value) => {\\n              // it looks like Hapi doesn't support multiple headers with the same name,\\n              // appending values is the closest we can come to the AWS behavior.\\n              response.header(headerKey, value, {\\n                append: true,\\n              })\\n            })\\n          }\\n        })\\n\\n        if (\\n          endpoint.isHttpApi &&\\n          endpoint.payload === \\\"2.0\\\" &&\\n          result.cookies\\n        ) {\\n          result.cookies.forEach(parseCookies)\\n        }\\n\\n        response.header(\\\"Content-Type\\\", \\\"application/json\\\", {\\n          duplicate: false,\\n          override: false,\\n        })\\n\\n        if (typeof result === \\\"string\\\") {\\n          response.source = stringify(result)\\n        } else if (result && result.body !== undefined) {\\n          if (result.isBase64Encoded) {\\n            response.encoding = \\\"binary\\\"\\n            response.source = Buffer.from(result.body, \\\"base64\\\")\\n            response.variety = \\\"buffer\\\"\\n          } else {\\n            if (result && result.body && typeof result.body !== \\\"string\\\") {\\n              // FIXME TODO we should probably just write to console instead of returning a payload\\n              return this.#reply502(\\n                response,\\n                \\\"According to the API Gateway specs, the body content must be stringified. Check your Lambda response and make sure you are invoking JSON.stringify(YOUR_CONTENT) on your body object\\\",\\n                {},\\n              )\\n            }\\n            response.source = result.body\\n          }\\n        }\\n      }\\n\\n      return response\\n    }]\",\n  \"options\": {\n    \"auth\": null,\n    \"cors\": null,\n    \"response\": {\n      \"emptyStatusCode\": 200\n    },\n    \"state\": {\n      \"failAction\": \"error\",\n      \"parse\": true\n    },\n    \"timeout\": {\n      \"socket\": false\n    },\n    \"payload\": {\n      \"maxBytes\": 10485760,\n      \"parse\": false\n    },\n    \"tags\": [\n      \"api\"\n    ]\n  },\n  \"path\": \"/{proxy*}\",\n  \"method\" \u001b[31m[1]\u001b[0m: \"\"\n}\n\u001b[31m\n[1] \"method\" is not allowed to be empty\u001b[0m",
      "stack": "Error: Invalid route options ( /{proxy*}) {\n  \"handler\": \"[async (request, h) => {\\n      const requestPath =\\n        endpoint.isHttpApi || this.#options.noPrependStageInUrl\\n          ? request.path\\n          : request.path.substr(`/${stage}`.length)\\n\\n      // payload processing\\n      const encoding = detectEncoding(request)\\n\\n      request.raw.req.payload = request.payload\\n      request.payload = request.payload && request.payload.toString(encoding)\\n      request.rawPayload = request.payload\\n\\n      // incoming request message\\n      log.notice()\\n\\n      log.notice()\\n      log.notice(`${method} ${request.path} (Î»: ${functionKey})`)\\n\\n      // check for APIKey\\n      if (\\n        (protectedRoute === `${hapiMethod}#${hapiPath}` ||\\n          protectedRoute === `ANY#${hapiPath}`) &&\\n        !this.#options.noAuth\\n      ) {\\n        const errorResponse = () =>\\n          h\\n            .response({\\n              message: \\\"Forbidden\\\",\\n            })\\n            .code(403)\\n            .header(\\\"x-amzn-ErrorType\\\", \\\"ForbiddenException\\\")\\n            .type(\\\"application/json\\\")\\n\\n        const apiKey = request.headers[\\\"x-api-key\\\"]\\n\\n        if (apiKey) {\\n          if (!this.#apiKeysValues.has(apiKey)) {\\n            log.debug(\\n              `Method '${method}' of function '${functionKey}' token '${apiKey}' not valid.`,\\n            )\\n\\n            return errorResponse()\\n          }\\n        } else if (\\n          request.auth &&\\n          request.auth.credentials &&\\n          request.auth.credentials.usageIdentifierKey\\n        ) {\\n          const { usageIdentifierKey } = request.auth.credentials\\n\\n          if (!this.#apiKeysValues.has(usageIdentifierKey)) {\\n            log.debug(\\n              `Method '${method}' of function '${functionKey}' token '${usageIdentifierKey}' not valid.`,\\n            )\\n\\n            return errorResponse()\\n          }\\n        } else {\\n          log.debug(`Missing 'x-api-key' on private function '${functionKey}'.`)\\n\\n          return errorResponse()\\n        }\\n      }\\n\\n      const response = h.response()\\n      const contentType = request.mime || \\\"application/json\\\" // default content type\\n\\n      const { integration, requestTemplates } = endpoint\\n\\n      // default request template to '' if we don't have a definition pushed in from serverless or endpoint\\n      const requestTemplate =\\n        requestTemplates !== undefined && integration === \\\"AWS\\\"\\n          ? requestTemplates[contentType]\\n          : \\\"\\\"\\n\\n      const schemas =\\n        endpoint?.request?.schemas === undefined\\n          ? \\\"\\\"\\n          : endpoint.request.schemas[contentType]\\n\\n      // https://hapijs.com/api#route-configuration doesn't seem to support selectively parsing\\n      // so we have to do it ourselves\\n      const contentTypesThatRequirePayloadParsing = [\\n        \\\"application/json\\\",\\n        \\\"application/vnd.api+json\\\",\\n      ]\\n\\n      if (\\n        contentTypesThatRequirePayloadParsing.includes(contentType) &&\\n        request.payload &&\\n        request.payload.length > 1\\n      ) {\\n        try {\\n          if (!request.payload || request.payload.length === 0) {\\n            request.payload = \\\"{}\\\"\\n          }\\n\\n          request.payload = parse(request.payload)\\n        } catch (err) {\\n          log.debug(\\\"error in converting request.payload to JSON:\\\", err)\\n        }\\n      }\\n\\n      log.debug(\\\"contentType:\\\", contentType)\\n      log.debug(\\\"requestTemplate:\\\", requestTemplate)\\n      log.debug(\\\"payload:\\\", request.payload)\\n\\n      /* REQUEST PAYLOAD SCHEMA VALIDATION */\\n      if (schemas) {\\n        log.debug(\\\"schemas:\\\", schemas)\\n\\n        try {\\n          payloadSchemaValidator(schemas, request.payload)\\n        } catch (err) {\\n          return this.#reply400(response, err.message, err)\\n        }\\n      }\\n\\n      /* REQUEST TEMPLATE PROCESSING (event population) */\\n\\n      let event = {}\\n\\n      if (integration === \\\"AWS\\\") {\\n        if (requestTemplate) {\\n          try {\\n            log.debug(\\\"_____ REQUEST TEMPLATE PROCESSING _____\\\")\\n\\n            event = new LambdaIntegrationEvent(\\n              request,\\n              stage,\\n              requestTemplate,\\n              requestPath,\\n            ).create()\\n          } catch (err) {\\n            return this.#reply502(\\n              response,\\n              `Error while parsing template \\\"${contentType}\\\" for ${functionKey}`,\\n              err,\\n            )\\n          }\\n        } else if (typeof request.payload === \\\"object\\\") {\\n          event = request.payload || {}\\n        }\\n      } else if (integration === \\\"AWS_PROXY\\\") {\\n        const lambdaProxyIntegrationEvent =\\n          endpoint.isHttpApi && endpoint.payload === \\\"2.0\\\"\\n            ? new LambdaProxyIntegrationEventV2(\\n                request,\\n                stage,\\n                endpoint.routeKey,\\n                additionalRequestContext,\\n              )\\n            : new LambdaProxyIntegrationEvent(\\n                request,\\n                stage,\\n                requestPath,\\n                endpoint.isHttpApi ? endpoint.routeKey : null,\\n                additionalRequestContext,\\n              )\\n\\n        event = lambdaProxyIntegrationEvent.create()\\n\\n        const customizations = this.#serverless.service.custom\\n        const hasCustomAuthProvider =\\n          customizations?.offline?.customAuthenticationProvider\\n\\n        if (!endpoint.authorizer && !hasCustomAuthProvider) {\\n          log.debug(\\\"no authorizer configured, deleting authorizer payload\\\")\\n          delete event.requestContext.authorizer\\n        }\\n      }\\n\\n      log.debug(\\\"event:\\\", event)\\n\\n      const lambdaFunction = this.#lambda.get(functionKey)\\n\\n      lambdaFunction.setEvent(event)\\n\\n      let result\\n      let err\\n\\n      try {\\n        result = await lambdaFunction.runHandler()\\n      } catch (_err) {\\n        err = _err\\n      }\\n\\n      // const processResponse = (err, data) => {\\n      // Everything in this block happens once the lambda function has resolved\\n\\n      log.debug(\\\"_____ HANDLER RESOLVED _____\\\")\\n\\n      let responseName = \\\"default\\\"\\n      const { contentHandling, responseContentType } = endpoint\\n\\n      /* RESPONSE SELECTION (among endpoint's possible responses) */\\n\\n      // Failure handling\\n      let errorStatusCode = \\\"502\\\"\\n\\n      if (err) {\\n        const errorMessage = (err.message || err).toString()\\n\\n        const found = errorMessage.match(/\\\\[(\\\\d{3})]/)\\n\\n        if (found && found.length > 1) {\\n          ;[, errorStatusCode] = found\\n        } else {\\n          errorStatusCode = \\\"502\\\"\\n        }\\n\\n        // Mocks Lambda errors\\n        result = {\\n          errorMessage,\\n          errorType: err.constructor.name,\\n          stackTrace: this.#getArrayStackTrace(err.stack),\\n        }\\n\\n        log.error(errorMessage)\\n\\n        for (const [key, value] of entries(endpoint.responses)) {\\n          if (\\n            key !== \\\"default\\\" &&\\n            `^${value.selectionPattern || key}$`.test(errorMessage)\\n          ) {\\n            responseName = key\\n            break\\n          }\\n        }\\n      }\\n\\n      log.debug(`Using response '${responseName}'`)\\n\\n      const chosenResponse = endpoint.responses?.[responseName] ?? {}\\n      /* RESPONSE PARAMETERS PROCCESSING */\\n\\n      const { responseParameters } = chosenResponse\\n\\n      if (responseParameters) {\\n        log.debug(\\\"_____ RESPONSE PARAMETERS PROCCESSING _____\\\")\\n        log.debug(\\n          `Found ${\\n            keys(responseParameters).length\\n          } responseParameters for '${responseName}' response`,\\n        )\\n\\n        // responseParameters use the following shape: \\\"key\\\": \\\"value\\\"\\n        entries(responseParameters).forEach(([key, value]) => {\\n          const keyArray = key.split(\\\".\\\") // eg: \\\"method.response.header.location\\\"\\n          const valueArray = value.split(\\\".\\\") // eg: \\\"integration.response.body.redirect.url\\\"\\n\\n          log.debug(`Processing responseParameter \\\"${key}\\\": \\\"${value}\\\"`)\\n\\n          // For now the plugin only supports modifying headers\\n          if (key.startsWith(\\\"method.response.header\\\") && keyArray[3]) {\\n            const headerName = keyArray.slice(3).join(\\\".\\\")\\n            let headerValue\\n\\n            log.debug(\\\"Found header in left-hand:\\\", headerName)\\n\\n            if (value.startsWith(\\\"integration.response\\\")) {\\n              if (valueArray[2] === \\\"body\\\") {\\n                log.debug(\\\"Found body in right-hand\\\")\\n\\n                headerValue = valueArray[3]\\n                  ? jsonPath(result, valueArray.slice(3).join(\\\".\\\"))\\n                  : result\\n\\n                headerValue = headerValue == null ? \\\"\\\" : String(headerValue)\\n              } else {\\n                log.notice()\\n\\n                log.warning()\\n                log.warning(\\n                  `Offline plugin only supports \\\"integration.response.body[.JSON_path]\\\" right-hand responseParameter. Found \\\"${value}\\\" (for \\\"${key}\\\"\\\") instead. Skipping.`,\\n                )\\n\\n                this.#logPluginIssue()\\n                log.notice()\\n              }\\n            } else {\\n              headerValue = /^'.*'$/.test(value) ? value.slice(1, -1) : value // See #34\\n            }\\n            // Applies the header;\\n            if (headerValue === \\\"\\\") {\\n              log.warning(\\n                `Empty value for responseParameter \\\"${key}\\\": \\\"${value}\\\", it won't be set`,\\n              )\\n            } else {\\n              log.debug(\\n                `Will assign \\\"${headerValue}\\\" to header \\\"${headerName}\\\"`,\\n              )\\n\\n              response.header(headerName, headerValue)\\n            }\\n          } else {\\n            log.notice()\\n\\n            log.warning()\\n            log.warning(\\n              `Offline plugin only supports \\\"method.response.header.PARAM_NAME\\\" left-hand responseParameter. Found \\\"${key}\\\" instead. Skipping.`,\\n            )\\n\\n            this.#logPluginIssue()\\n            log.notice()\\n          }\\n        })\\n      }\\n\\n      let statusCode = 200\\n\\n      if (integration === \\\"AWS\\\") {\\n        const endpointResponseHeaders =\\n          (endpoint.response && endpoint.response.headers) || {}\\n\\n        entries(endpointResponseHeaders)\\n          .filter(\\n            ([, value]) => typeof value === \\\"string\\\" && /^'.*?'$/.test(value),\\n          )\\n          .forEach(([key, value]) => response.header(key, value.slice(1, -1)))\\n\\n        /* LAMBDA INTEGRATION RESPONSE TEMPLATE PROCCESSING */\\n\\n        // If there is a responseTemplate, we apply it to the result\\n        const { responseTemplates } = chosenResponse\\n\\n        if (\\n          typeof responseTemplates === \\\"object\\\" &&\\n          keys(responseTemplates).length > 0\\n        ) {\\n          // BAD IMPLEMENTATION: first key in responseTemplates\\n          const responseTemplate = responseTemplates[responseContentType]\\n\\n          if (responseTemplate && responseTemplate !== \\\"\\\\n\\\") {\\n            log.debug(\\\"_____ RESPONSE TEMPLATE PROCCESSING _____\\\")\\n            log.debug(`Using responseTemplate '${responseContentType}'`)\\n\\n            try {\\n              const reponseContext = new VelocityContext(\\n                request,\\n                stage,\\n                result,\\n              ).getContext()\\n\\n              result = renderVelocityTemplateObject(\\n                {\\n                  root: responseTemplate,\\n                },\\n                reponseContext,\\n              ).root\\n            } catch (error) {\\n              log.error(\\n                `Error while parsing responseTemplate '${responseContentType}' for lambda ${functionKey}:\\\\n${error.stack}`,\\n              )\\n            }\\n          }\\n        }\\n\\n        /* LAMBDA INTEGRATION HAPIJS RESPONSE CONFIGURATION */\\n        statusCode = chosenResponse.statusCode || 200\\n\\n        if (err) {\\n          statusCode = errorStatusCode\\n        }\\n\\n        if (!chosenResponse.statusCode) {\\n          log.notice()\\n\\n          log.warning()\\n          log.warning(`No statusCode found for response \\\"${responseName}\\\".`)\\n        }\\n\\n        response.header(\\\"Content-Type\\\", responseContentType, {\\n          override: false, // Maybe a responseParameter set it already. See #34\\n        })\\n\\n        response.statusCode = statusCode\\n\\n        if (contentHandling === \\\"CONVERT_TO_BINARY\\\") {\\n          response.encoding = \\\"binary\\\"\\n          response.source = Buffer.from(result, \\\"base64\\\")\\n          response.variety = \\\"buffer\\\"\\n        } else if (typeof result === \\\"string\\\") {\\n          response.source = stringify(result)\\n        } else {\\n          response.source = result\\n        }\\n      } else if (integration === \\\"AWS_PROXY\\\") {\\n        /* LAMBDA PROXY INTEGRATION HAPIJS RESPONSE CONFIGURATION */\\n\\n        if (\\n          endpoint.isHttpApi &&\\n          endpoint.payload === \\\"2.0\\\" &&\\n          (typeof result === \\\"string\\\" || !result.statusCode)\\n        ) {\\n          const body = typeof result === \\\"string\\\" ? result : stringify(result)\\n          result = {\\n            body,\\n            headers: {\\n              \\\"Content-Type\\\": \\\"application/json\\\",\\n            },\\n            isBase64Encoded: false,\\n            statusCode: 200,\\n          }\\n        }\\n\\n        if (result && !result.errorType) {\\n          statusCode = result.statusCode || 200\\n        } else if (err) {\\n          statusCode = errorStatusCode || 502\\n        } else {\\n          statusCode = 502\\n        }\\n\\n        response.statusCode = statusCode\\n\\n        const headers = {}\\n\\n        if (result && result.headers) {\\n          entries(result.headers).forEach(([headerKey, headerValue]) => {\\n            headers[headerKey] = (headers[headerKey] || []).concat(headerValue)\\n          })\\n        }\\n        if (result && result.multiValueHeaders) {\\n          entries(result.multiValueHeaders).forEach(\\n            ([headerKey, headerValue]) => {\\n              headers[headerKey] = (headers[headerKey] || []).concat(\\n                headerValue,\\n              )\\n            },\\n          )\\n        }\\n\\n        log.debug(\\\"headers\\\", headers)\\n\\n        const parseCookies = (headerValue) => {\\n          const cookieName = headerValue.slice(0, headerValue.indexOf(\\\"=\\\"))\\n          const cookieValue = headerValue.slice(headerValue.indexOf(\\\"=\\\") + 1)\\n\\n          h.state(cookieName, cookieValue, {\\n            encoding: \\\"none\\\",\\n            strictHeader: false,\\n          })\\n        }\\n\\n        entries(headers).forEach(([headerKey, headerValue]) => {\\n          if (headerKey.toLowerCase() === \\\"set-cookie\\\") {\\n            headerValue.forEach(parseCookies)\\n          } else {\\n            headerValue.forEach((value) => {\\n              // it looks like Hapi doesn't support multiple headers with the same name,\\n              // appending values is the closest we can come to the AWS behavior.\\n              response.header(headerKey, value, {\\n                append: true,\\n              })\\n            })\\n          }\\n        })\\n\\n        if (\\n          endpoint.isHttpApi &&\\n          endpoint.payload === \\\"2.0\\\" &&\\n          result.cookies\\n        ) {\\n          result.cookies.forEach(parseCookies)\\n        }\\n\\n        response.header(\\\"Content-Type\\\", \\\"application/json\\\", {\\n          duplicate: false,\\n          override: false,\\n        })\\n\\n        if (typeof result === \\\"string\\\") {\\n          response.source = stringify(result)\\n        } else if (result && result.body !== undefined) {\\n          if (result.isBase64Encoded) {\\n            response.encoding = \\\"binary\\\"\\n            response.source = Buffer.from(result.body, \\\"base64\\\")\\n            response.variety = \\\"buffer\\\"\\n          } else {\\n            if (result && result.body && typeof result.body !== \\\"string\\\") {\\n              // FIXME TODO we should probably just write to console instead of returning a payload\\n              return this.#reply502(\\n                response,\\n                \\\"According to the API Gateway specs, the body content must be stringified. Check your Lambda response and make sure you are invoking JSON.stringify(YOUR_CONTENT) on your body object\\\",\\n                {},\\n              )\\n            }\\n            response.source = result.body\\n          }\\n        }\\n      }\\n\\n      return response\\n    }]\",\n  \"options\": {\n    \"auth\": null,\n    \"cors\": null,\n    \"response\": {\n      \"emptyStatusCode\": 200\n    },\n    \"state\": {\n      \"failAction\": \"error\",\n      \"parse\": true\n    },\n    \"timeout\": {\n      \"socket\": false\n    },\n    \"payload\": {\n      \"maxBytes\": 10485760,\n      \"parse\": false\n    },\n    \"tags\": [\n      \"api\"\n    ]\n  },\n  \"path\": \"/{proxy*}\",\n  \"method\" \u001b[31m[1]\u001b[0m: \"\"\n}\n\u001b[31m\n[1] \"method\" is not allowed to be empty\u001b[0m\n    at exports.apply (/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/node_modules/@hapi/hapi/lib/config.js:20:15)\n    at new module.exports.internals.Route (/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/node_modules/@hapi/hapi/lib/route.js:34:16)\n    at internals.Server._addRoute (/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/node_modules/@hapi/hapi/lib/server.js:525:23)\n    at internals.Server.route (/Users/antoni/Documents/Antoni Workspace/gitlook-nest-backend/node_modules/@hapi/hapi/lib/server.js:518:22)\n    at HttpServer.createRoutes (file:///Users/antoni/Documents/Antoni%20Workspace/gitlook-nest-backend/node_modules/serverless-offline/src/events/http/HttpServer.js:1121:18)\n    at #createEvent (file:///Users/antoni/Documents/Antoni%20Workspace/gitlook-nest-backend/node_modules/serverless-offline/src/events/http/Http.js:41:22)\n    at file:///Users/antoni/Documents/Antoni%20Workspace/gitlook-nest-backend/node_modules/serverless-offline/src/events/http/Http.js:46:24\n    at Array.forEach (<anonymous>)\n    at Http.create (file:///Users/antoni/Documents/Antoni%20Workspace/gitlook-nest-backend/node_modules/serverless-offline/src/events/http/Http.js:45:12)\n    at #createHttp (file:///Users/antoni/Documents/Antoni%20Workspace/gitlook-nest-backend/node_modules/serverless-offline/src/ServerlessOffline.js:201:16)"
    },
    "serviceRawFile": "service: gitlook-nest-backend\n\nframeworkVersion: '4'\n\nprovider:\n  name: aws\n  runtime: nodejs20.x # Use a recent Node.js runtime\n  region: ap-northeast-3 # Choose your desired AWS region\n  memorySize: 1024 # Memory allocated to your Lambda function (in MB)\n  timeout: 30 # Maximum execution time for your Lambda function (in seconds)\n  stage: dev # Deployment stage (e.g., dev, prod)\n  environment:\n    GITHUB_CLIENT_ID: ${ssm:/gitlook-nest-backend/${sls:stage}/github-client-id}\n    GITHUB_CLIENT_SECRET: ${ssm:/gitlook-nest-backend/${sls:stage}/github-client-secret}\n  iam:\n    role:\n      statements:\n        - Effect: Allow\n          Action:\n            - ssm:GetParameter\n          Resource:\n            - 'arn:aws:ssm:${aws:region}:*:parameter/gitlook-nest-backend/${sls:stage}/github-client-id'\n            - 'arn:aws:ssm:${aws:region}:*:parameter/gitlook-nest-backend/${sls:stage}/github-client-secret'\n\n# New 'build' block for native esbuild configuration\nbuild:\n  esbuild:\n    bundle: true\n    minify: false # Set to true for production to reduce size\n    sourcemap: true # Keep true for debugging, false for production if not needed\n    target: 'node20' # Match your Lambda runtime\n    external: # Any modules that should NOT be bundled but provided by Lambda or layers\n      - '@aws-sdk/*' # AWS SDK is typically available in Lambda runtime\n\nfunctions:\n  main:\n    handler: lambda.handler # The handler points directly to the compiled JS file in the root of the zip\n    events:\n      - httpApi:\n          path: /\n          method: '*'\n      - httpApi:\n          path: /{proxy+}\n\npackage:\n  patterns:\n    # Serverless v4 with esbuild handles bundling for 'dist' automatically\n    # You might not need explicit patterns if esbuild bundles everything correctly\n    # However, it's good practice to ensure only what's needed is included.\n    - '!node_modules/**' # Esbuild bundles, so node_modules are not needed separately\n    - '!src/**'\n    - '!test/**'\n    - 'package.json'\n    - 'package-lock.json'\n    - '!serverless.yml' # Exclude serverless.yml from the final package if you want a cleaner bundle (optional)\n    # The esbuild output will be put directly into the zip file root, so no 'dist/**' is strictly needed in patterns\n\nplugins:\n  - serverless-offline # Still useful for local development",
    "command": [
      "offline",
      "start"
    ],
    "options": {},
    "orgId": "e80db0ff-5c71-4a86-845a-4dffef9a399f",
    "orgName": "aratech",
    "userId": "7cPSCK7dDVjr93cxP2",
    "userName": "aratech",
    "serviceProviderAwsAccountId": "249133131158",
    "serviceProviderAwsCfStackId": null,
    "serviceProviderAwsCfStackCreated": null,
    "serviceProviderAwsCfStackUpdated": null,
    "serviceProviderAwsCfStackStatus": null,
    "serviceProviderAwsCfStackOutputs": null
  }
}